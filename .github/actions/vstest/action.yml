workflow:

  name: VSTest Reusable Workflow

  inputs:
    runsOn:
      required: true
      type: string
    dotnet-version:
      required: true
      type: string
    testSelector:
      required: true
      type: string
      default: "testAssemblies"
    testAssemblyVer2:
      required: true
      type: string
    configuration:
      required: true
      type: string
    platform:
      required: false
      type: string
    code-coverage-enabled:
      required: false
      type: boolean
    test-run-title:
      required: false
      type: string
    run-in-parallel:
      required: false
      type: boolean
    testPlan:
      required: false
      type: string
    testSuite:
      required: false
      type: string
    testConfiguration:
      required: false
      type: string
    tcmTestRun:
      required: false
      type: string
    uiTests:
      required: false
      type: boolean
    vsTestVersion:
      required: false
      type: string
    vstestLocation:
      required: false
      type: string
    diagnosticsEnabled:
      required: false
      type: boolean
    rerunFailedTests:
      required: false
      type: boolean
    rerunType:
      required: false
      type: string
    rerunMaxAttempts:
      required: false
      type: string
    dontDistribute:
      required: false
      type: boolean
    searchFolder:
      required: true
      type: string
    resultsFolder:
      required: false
      type: string
      default: ${{ github.workspace }}/TestResults
    testFiltercriteria:
      required: false
      type: string
    runOnlyImpactedTests:
      required: false
      type: boolean
      default: false
    runAllTestsAfterXBuilds:
      required: false
      type: string
      default: "50"

  runs:
    using: 'composite'
    steps:
      - name: Restore dependencies
        shell: pwsh
        run: dotnet restore

      - name: Build solution
        shell: pwsh
        run: dotnet build --configuration ${{ inputs.configuration }} --no-restore

      - name: Debug Directory Structure
        shell: pwsh
        run: |
          # Debug: List all files in the working directory
          $workingDirectory = "${{ github.workspace }}"
          Set-Location -Path $workingDirectory
          Write-Host "Listing all files in the working directory:"
          Get-ChildItem -Path $workingDirectory -Recurse | ForEach-Object { Write-Host $_.FullName }

      - name: Run tests with Visual Studio Test Runner
        shell: pwsh
        run: |
          # Ensure the correct working directory
          $workingDirectory = "${{ inputs.searchFolder }}"
          Set-Location -Path $workingDirectory

          # Convert inputs to boolean
          $codeCoverageEnabled = [bool]::Parse("${{ inputs.code-coverage-enabled }}")
          $runInParallel = [bool]::Parse("${{ inputs.run-in-parallel }}")
          $diagnosticsEnabled = [bool]::Parse("${{ inputs.diagnosticsEnabled }}")
          $rerunFailedTests = [bool]::Parse("${{ inputs.rerunFailedTests }}")
          $uiTests = [bool]::Parse("${{ inputs.uiTests }}")
          $runOnlyImpactedTests = [bool]::Parse("${{ inputs.runOnlyImpactedTests }}")

          # Resolve test assemblies from the bin directory
          $testAssemblies = Get-ChildItem -Path $workingDirectory -Recurse -File | ForEach-Object { $_.FullName }
          if (-not $testAssemblies) {
            Write-Error "No test assemblies found."
            exit 1
          }

          # Debug: List resolved test assemblies
          Write-Host "Resolved test assemblies:"
          $testAssemblies | ForEach-Object { Write-Host $_ }

          # Construct VSTest arguments
          $vstestArgs = @()
          if ($codeCoverageEnabled) { $vstestArgs += '/EnableCodeCoverage' }
          if ($runInParallel) { $vstestArgs += '/Parallel' }
          if ($diagnosticsEnabled) { $vstestArgs += '/Diag:logfile.txt' }
          if ($rerunFailedTests -and -not [string]::IsNullOrEmpty("${{ inputs.rerunType }}")) { $vstestArgs += "/Rerun:${{ inputs.rerunType }}" }
          if (-not [string]::IsNullOrEmpty("${{ inputs.testFiltercriteria }}")) { $vstestArgs += "/TestCaseFilter:${{ inputs.testFiltercriteria }}" }
          if ($runOnlyImpactedTests) { 
            $vstestArgs += "/ImpactedTests"
            $vstestArgs += "/RunAllTestsAfter:${{ inputs.runAllTestsAfterXBuilds }}"
          }
          if ($uiTests) { $vstestArgs += "/UITests" }

          # Validate vstestLocation
          if (-not [string]::IsNullOrEmpty("${{ inputs.vstestLocation }}")) {
            $vstestLocation = "${{ inputs.vstestLocation }}"
          } else {
            Write-Error "vstestLocation is not provided or is empty."
            exit 1
          }

          # Run VSTest for each resolved test assembly
          foreach ($testAssembly in $testAssemblies) {
            $command = "$vstestLocation `"$testAssembly`" /Settings:TestSettings.runsettings /ResultsDirectory:${{ inputs.resultsFolder }} $($vstestArgs -join ' ')"
            Write-Host "Executing: $command"

            # Ensure the command is valid before executing
            if (-not [string]::IsNullOrEmpty($command)) {
              Invoke-Expression $command
            } else {
              Write-Error "The constructed command is empty or invalid."
              exit 1
            }
          }
